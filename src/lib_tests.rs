use serde::Deserialize;

use crate::{Manifest, Resolution, ResolutionConfig};

#[derive(Deserialize)]
struct Test {
    it: String,
    imported: String,
    importer: String,
    expected: String,
}

#[derive(Deserialize)]
struct TestSuite {
    manifest: Manifest,
    tests: Vec<Test>,
}

#[cfg(test)]
mod tests {
    use std::{fs, path::PathBuf};

    use super::*;
    use crate::{
        ResolutionHost, init_pnp_manifest, load_pnp_manifest, parse_bare_identifier,
        resolve_to_unqualified, resolve_to_unqualified_via_manifest,
    };

    #[test]
    fn example() {
        let manifest = load_pnp_manifest("data/pnp-yarn-v3.cjs").unwrap();

        let host = ResolutionHost {
            find_pnp_manifest: Box::new(move |_| Ok(Some(manifest.clone()))),
            ..Default::default()
        };

        let config = ResolutionConfig { host, ..Default::default() };

        let resolution = resolve_to_unqualified(
            "lodash/cloneDeep",
            std::path::PathBuf::from("/path/to/file"),
            &config,
        );

        match resolution {
            Ok(Resolution::Resolved(_path, _subpath)) => {
                // path = "/path/to/lodash.zip"
                // subpath = "cloneDeep"
            }
            Ok(Resolution::Skipped) => {
                // This is returned when the PnP resolver decides that it shouldn't
                // handle the resolution for this particular specifier. In that case,
                // the specifier should be forwarded to the default resolver.
            }
            Err(_err) => {
                // An error happened during the resolution. Falling back to the default
                // resolver isn't recommended.
            }
        };
    }

    #[cfg(not(target_os = "windows"))]
    #[test]
    fn test_load_pnp_manifest() {
        load_pnp_manifest("data/pnp-yarn-v3.cjs")
            .expect("Assertion failed: Expected to load the .pnp.cjs file generated by Yarn 3");

        load_pnp_manifest("data/pnp-yarn-v4.cjs")
            .expect("Assertion failed: Expected to load the .pnp.cjs file generated by Yarn 4");
    }

    #[cfg(not(target_os = "windows"))]
    #[test]
    fn test_resolve_unqualified() {
        let expectations_path = std::env::current_dir()
            .expect("Assertion failed: Expected a valid current working directory")
            .join("data/test-expectations.json");

        let manifest_content = fs::read_to_string(&expectations_path)
            .expect("Assertion failed: Expected the expectations to be found");

        let mut test_suites: Vec<TestSuite> = serde_json::from_str(&manifest_content)
            .expect("Assertion failed: Expected the expectations to be loaded");

        for test_suite in test_suites.iter_mut() {
            let manifest = &mut test_suite.manifest;
            init_pnp_manifest(manifest, &PathBuf::from("/path/to/project/.pnp.cjs"));

            for test in test_suite.tests.iter() {
                let specifier = &test.imported;
                let parent = &PathBuf::from(&test.importer).join("fooo");

                let manifest_copy = manifest.clone();

                let host = ResolutionHost {
                    find_pnp_manifest: Box::new(move |_| Ok(Some(manifest_copy.clone()))),
                    ..Default::default()
                };

                let config = ResolutionConfig { host, ..Default::default() };

                let resolution = resolve_to_unqualified(specifier, parent, &config);

                match resolution {
                    Ok(Resolution::Resolved(path, _subpath)) => {
                        assert_eq!(path.to_string_lossy(), test.expected, "{}", test.it);
                    }
                    Ok(Resolution::Skipped) => {
                        assert_eq!(specifier, &test.expected, "{}", test.it);
                    }
                    Err(err) => {
                        assert_eq!(test.expected, "error!", "{}: {}", test.it, err.to_string());
                    }
                }
            }
        }
    }

    #[test]
    fn test_edge_case_one_pkg_cached_and_unplugged() {
        let manifest = {
            let manifest_json_path =
                std::env::current_dir().unwrap().join("./data/edge_case_manifest_state.json");
            let manifest_content = fs::read_to_string(&manifest_json_path).unwrap();
            let mut manifest = serde_json::from_str::<Manifest>(&manifest_content).unwrap();
            init_pnp_manifest(&mut manifest, manifest_json_path);
            manifest
        };

        let issuer = std::env::current_dir().unwrap().
            join("data/.yarn/unplugged/@carbon-icons-react-virtual-379302d360/node_modules/@carbon/icons-react/es/");

        let resolution =
            resolve_to_unqualified_via_manifest(&manifest, "@carbon/icon-helpers", &issuer)
                .unwrap();

        match resolution {
            Resolution::Resolved(resolved, _) => {
                assert!(resolved.ends_with(".yarn/unplugged/@carbon-icon-helpers-npm-10.54.0-a58f8b7b6c/node_modules/@carbon/icon-helpers"))
            }
            _ => {
                panic!("Unexpected resolve failed");
            }
        }
    }

    #[test]
    fn test_parse_single_package_name() {
        let parsed = parse_bare_identifier("pkg");
        assert_eq!(parsed, Ok(("pkg".to_string(), None)));
    }

    #[test]
    fn test_parse_scoped_package_name() {
        let parsed = parse_bare_identifier("@scope/pkg");
        assert_eq!(parsed, Ok(("@scope/pkg".to_string(), None)));
    }

    #[test]
    fn test_parse_package_name_with_long_subpath() {
        let parsed = parse_bare_identifier("pkg/a/b/c/index.js");
        assert_eq!(parsed, Ok(("pkg".to_string(), Some("a/b/c/index.js".to_string()))));
    }

    #[test]
    fn test_parse_scoped_package_with_long_subpath() {
        let parsed = parse_bare_identifier("@scope/pkg/a/b/c/index.js");
        assert_eq!(parsed, Ok(("@scope/pkg".to_string(), Some("a/b/c/index.js".to_string()))));
    }
}
